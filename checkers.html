<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>WebAppDev by zbowhay</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- CSS Style For This Page -->
    <style>

      #gameCanvas{
        display: block;
        position:absolute;
        margin: auto;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        overflow: hidden; /* Disable scrollbars */
      }

      body{
        background-color: #555;
      }

    </style>
    <!-- end of CSS -->
  </head>

  <body>
    <!-- Body will hold the game canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <script type="text/javascript">
    
    // Variables...
     var

     canvas,
     ctx,
     width,
     height,

     readyState = false,
     pieceSelected = [false, null],
     aJumpMoves = [/*index*/[/*boardX, boardY, pieceNum*/], [], [], []],
     checkerPieceArray,

     //Image vars
     background,
     redChips,
     redChipsSelected,
     redChipsKing,
     redChipsKingSelected,
     blackChips,
     blackChipsSelected,
     blackChipsKing,
     blackChipsKingSelected,
     aSquare,

     redTurn = true;

     // RUN THE PROGRAM!

     main();

     function main(){
      // because the images are loaded dynamically with javascript
      // the code needs to fully iterate itself one time before 
      // all of the necessary data is loaded/ready for game play
      // to begin.  Therefore, readyState is here to inform the
      // program when that has been accomplished.
      if(readyState == false)
      {
        init();
      }
      else // readyState == true // Begin gameplay
      {
        window.alert("red goes first!");
        // refresh the canvas ten times after initial load to avoid any images not showing up on canvas
        refreshRedraw(10);        
      }
     }

     // CHECKERPIECE CLASS

     function checkerPiece(name, team, imagesrc){
      this.name = name;
      this.team = team;
      this.image = null;
      this.imageSource =  imagesrc;
      this.imageLoaded = false;
      this.x = null;
      this.y = null;
      this.boardX = null;
      this.boardY = null;
      this.isKing = false;


      this.sayName = function(){
        window.alert(this.name);
      }

      this.setName = function(name){
        this.name = name;
      };

      this.setTeam = function(teamColor){
        this.team = teamColor;
      };

      this.createImage = function(){
        this.image = new Image();
        this.image.onload = function(){
          this.imageLoaded = true;
        };
        this.image.src = this.imageSource;
      };

      this.setX = function(x){
        this.x = x;
      };

      this.setY = function(y){
        this.y = y;
      };

      this.setBoardX = function(x){
        this.boardX = x;
      };

      this.setBoardY = function(y){
        this.boardY = y;
      };

      this.printAttributeInfo = function(arrayPosition){
        window.alert('Information about checkerPieceArray[' + arrayPosition + '] object: \n' + 
        'Team: ' + checkerPieceArray[arrayPosition].team + '\n' +
        'Name: ' + checkerPieceArray[arrayPosition].name + '\n' +
        'ImageSource: ' + checkerPieceArray[arrayPosition].imageSource + '\n' +
        'X: ' + checkerPieceArray[arrayPosition].x + '\n' +
        'Y: ' + checkerPieceArray[arrayPosition].y + '\n' +
        'BoardX: ' + checkerPieceArray[arrayPosition].boardX + '\n' +
        'BoardY: ' + checkerPieceArray[arrayPosition].boardY);
      };

      //function isMoveOffBoard(pmovesArray){

     // };

      // check for available moves around checkerPiece
      this.availableMoves = function(n){
        if(checkerPieceArray[n].isKing == true){
          var aMoves = [true, true, true, true];

          // gather up potential moves
          var pMoves = [[checkerPieceArray[n].boardX - 1, checkerPieceArray[n].boardY - 1],// top left
          [checkerPieceArray[n].boardX + 1, checkerPieceArray[n].boardY - 1],// top right
          [checkerPieceArray[n].boardX - 1, checkerPieceArray[n].boardY + 1],// bottom left
          [checkerPieceArray[n].boardX + 1, checkerPieceArray[n].boardY + 1]];// bottom right

          // Evalute potential moves
          // check to see if move is off board
          for(u = 0; u < pMoves.length; u++){
            if(pMoves[u][0] < 0 || pMoves[u][0] > 7 || pMoves[u][1] < 0 || pMoves[u][1] > 7){
              aMoves[u] = false;
            }
          }   

          // check to see if other chips are already placed around this chip
          for(i = 0; i < checkerPieceArray.length; i++){
            for(j = 0; j < pMoves.length; j++){
              if(pMoves[j][0] == checkerPieceArray[i].boardX && pMoves[j][1] == checkerPieceArray[i].boardY){
                // this means that there is a checker piece already located in an adjacent location to the selected chip and therefore it cannot be moved to that location
                
                //However, if that piece is on the opposite team, check if it can be jumped
                if(redTurn == true){
                  if(j == 0) // top left
                  {
                    // if adjacent piece is an enemy piece
                    if(checkerPieceArray[i].team == 'black'){
                      // check to see if any checker piece is behind it or not so that it can be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] - 1 == checkerPieceArray[k].boardX && pMoves[j][1] - 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] - 1 < 0 || pMoves[j][1] - 1 < 0){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] -= 1;
                        pMoves[j][1] -= 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                        // i represents number of piece being jumped over
                      }
                    }
                    else // the adjacent piece is red, therefore it can't be jumped
                    {
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 1)// top right
                  {
                    if(checkerPieceArray[i].team == "black"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] + 1 == checkerPieceArray[k].boardX && pMoves[j][1] - 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] + 1 > 7 || pMoves[j][1] - 1 < 0){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] += 1;
                        pMoves[j][1] -= 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                        // i represents number of piece being jumped over
                      }
                    }
                    else{ // its a red piece in the way
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 2)// bottom left
                  {
                    if(checkerPieceArray[i].team == "black"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] - 1 == checkerPieceArray[k].boardX && pMoves[j][1] + 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] - 1 < 0 || pMoves[j][1] + 1 > 7){
                          aMoves[j] = false;
                        }

                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] -= 1;
                        pMoves[j][1] += 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                      }
                    }
                    else{ // its a red piece in the way
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 3)// bottom right
                  {
                    if(checkerPieceArray[i].team == "black"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] + 1 == checkerPieceArray[k].boardX && pMoves[j][1] + 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] + 1 > 7 || pMoves[j][1] + 1 > 7){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] += 1;
                        pMoves[j][1] += 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                      }
                    }
                    else{ // its a red piece in the way
                      aMoves[j] = false;
                    }
                  }
                }
                else // black's turn
                {
                  if(j == 0) // top left
                  {
                    // if adjacent piece is an enemy piece
                    if(checkerPieceArray[i].team == 'red'){
                      // check to see if any checker piece is behind it or not so that it can be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] - 1 == checkerPieceArray[k].boardX && pMoves[j][1] - 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] - 1 < 0 || pMoves[j][1] - 1 < 0){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] -= 1;
                        pMoves[j][1] -= 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                        // i represents number of piece being jumped over
                      }
                    }
                    else // the adjacent piece is black, therefore it can't be jumped
                    {
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 1)// top right
                  {
                    if(checkerPieceArray[i].team == "red"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] + 1 == checkerPieceArray[k].boardX && pMoves[j][1] - 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] + 1 > 7 || pMoves[j][1] - 1 < 0){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] += 1;
                        pMoves[j][1] -= 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                        // i represents number of piece being jumped over
                      }
                    }
                    else{ // its a black piece in the way
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 2)// bottom left
                  {
                    if(checkerPieceArray[i].team == "red"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] - 1 == checkerPieceArray[k].boardX && pMoves[j][1] + 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] - 1 < 0 || pMoves[j][1] + 1 > 7){
                          aMoves[j] = false;
                        }

                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] -= 1;
                        pMoves[j][1] += 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                      }
                    }
                    else{ // its a black piece in the way
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 3)// bottom right
                  {
                    if(checkerPieceArray[i].team == "red"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] + 1 == checkerPieceArray[k].boardX && pMoves[j][1] + 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] + 1 > 7 || pMoves[j][1] + 1 > 7){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] += 1;
                        pMoves[j][1] += 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                      }
                    }
                    else{ // its a black piece in the way
                      aMoves[j] = false;
                    }
                  }
                }
                //aMoves[j] = false;
              }
            }
          }                 
        }

        else// checkerPieceArray[n].isKing == false

        { 
          var aMoves = [true, true];

          // gather up potential moves for red chips
          if(checkerPieceArray[n].team == "red"){
            var pMoves = [
            [checkerPieceArray[n].boardX - 1, checkerPieceArray[n].boardY - 1],// top left
            [checkerPieceArray[n].boardX + 1, checkerPieceArray[n].boardY - 1]// top right
            ];
          }
          else{ //checkerPieceArray[n].team == "black"
            var pMoves = [
            [checkerPieceArray[n].boardX - 1, checkerPieceArray[n].boardY + 1],// bottom left
            [checkerPieceArray[n].boardX + 1, checkerPieceArray[n].boardY + 1]// bottom right
            ];
          }

          // Evaluate potential moves
          // check to see if move is off board
          for(u = 0; u < pMoves.length; u++){
            if(pMoves[u][0] < 0 || pMoves[u][0] > 7 || pMoves[u][1] < 0 || pMoves[u][1] > 7){
              aMoves[u] = false;
            }
          }

          // Check to see if other chips are already placed around this chip
          for(i = 0; i < checkerPieceArray.length; i++){
            for(j = 0; j < pMoves.length; j++){
              if(pMoves[j][0] == checkerPieceArray[i].boardX && pMoves[j][1] == checkerPieceArray[i].boardY){
                // this means that there is a checker piece already located in an adjacent location to the selected chip and therefore it cannot be moved to that location

                //However, if that piece is on the opposite team, check if it can be jumped
                if(redTurn == true){
                  if(j == 0){ // top left
                    if(checkerPieceArray[i].team == "black"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] - 1 == checkerPieceArray[k].boardX && pMoves[j][1] - 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] - 1 < 0 || pMoves[j][1] - 1 < 0){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] -= 1;
                        pMoves[j][1] -= 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                        // i represents number of piece being jumped over
                      }
                    }
                    else{ // its a red piece in the way
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 1){ // top right
                    if(checkerPieceArray[i].team == "black"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] + 1 == checkerPieceArray[k].boardX && pMoves[j][1] - 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] + 1 > 7 || pMoves[j][1] - 1 < 0){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] += 1;
                        pMoves[j][1] -= 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                        /*window.alert("aJumpMoves[" + j + "]: \n" + "[1][0]: " + aJumpMoves[j][0] + "\n[1][1]: " + aJumpMoves[j][1] + "\n[1][2]: " + aJumpMoves[j][2]);*/
                        // i represents number of piece being jumped over
                      }
                    }
                    else{ // its a red piece in the way
                      aMoves[j] = false;
                    }
                  }

                }

                else //redTurn == false

                {
                  if(j == 0){ // bottom left
                    if(checkerPieceArray[i].team == "red"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] - 1 == checkerPieceArray[k].boardX && pMoves[j][1] + 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] - 1 < 0 || pMoves[j][1] + 1 > 7){
                          aMoves[j] = false;
                        }

                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] -= 1;
                        pMoves[j][1] += 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                      }
                    }
                    else{ // its a black piece in the way
                      aMoves[j] = false;
                    }
                  }
                  else if(j == 1){ // bottom right
                    if(checkerPieceArray[i].team == "red"){
                      // check to see if any checker piece is behind the one trying to be jumped
                      for(k = 0; k < checkerPieceArray.length; k++){
                        if(pMoves[j][0] + 1 == checkerPieceArray[k].boardX && pMoves[j][1] + 1 == checkerPieceArray[k].boardY){
                          aMoves[j] = false;
                        }
                        // make sure jump isn't off board
                        if(pMoves[j][0] + 1 > 7 || pMoves[j][1] + 1 > 7){
                          aMoves[j] = false;
                        }
                      }
                      if(aMoves[j] != false){ // jump can be made
                        pMoves[j][0] += 1;
                        pMoves[j][1] += 1;
                        // store jump moves board coords and piece being jumped over
                        aJumpMoves[j] = [pMoves[j][0], pMoves[j][1], i];
                      }
                    }
                    else{ // its a black piece in the way
                      aMoves[j] = false;
                    }
                  }
                }
              }
            }
          }      
        }
        // debug to show the effects of evaluating 
        for(k = 0; k < aMoves.length; k++){
          //window.alert(aMoves[k]);
        }

        return [aMoves, pMoves];
      };
     }

     // FUNCTIONS


     // INSERT FUNCTION
     function insert(index, string, thisString) {
      if (index > 0)
      return thisString.substring(0, index) + string + thisString.substring(index, thisString.length);
      else
      return string + thisString;
     };


      // MAIN INIT FUNCTION
     function init(){
    // Initialize Canvas
    canvas = document.getElementById("gameCanvas");
    canvas.addEventListener("touchstart", touchDown, false);
    canvas.addEventListener("mousedown", mouseDown, false);
    
    width = window.innerWidth;
    height = window.innerHeight;

    if(width >=750){
      width = 750;
      height = width;
    }

    canvas.style.border = "1px solid #000";
    canvas.width = width;
    canvas.height = height;
    ctx = canvas.getContext("2d");

    // Init checkerPiece game objects array
    initCheckerPieceArray();

    //Draw the starting layout of game to canvas

    background = new Image();
    redChips = checkerPieceArray[12].image;
    blackChips = checkerPieceArray[0].image;
    redChipsSelected = new Image();
    blackChipsSelected = new Image();
    blackChipsKing = new Image();
    blackChipsKingSelected = new Image();
    redChipsKing = new Image();
    redChipsKingSelected = new Image();
    aSquare = new Image();


    background.src = 'Images/CheckerBoard.jpg';
    redChips.src = checkerPieceArray[12].imageSource;
    blackChips.src = checkerPieceArray[0].imageSource;
    redChipsSelected.src = 'Images/RedCheckerSelected.png';
    blackChipsSelected.src = 'Images/BlackCheckerSelected.png';
    blackChipsKing.src = 'Images/BlackCheckerKing.png'
    blackChipsKingSelected.src = 'Images/BlackCheckerKingSelected.png'
    redChipsKing.src = 'Images/RedCheckerKing.png';
    redChipsKingSelected.src = 'Images/RedCheckerKingSelected.png';
    aSquare.src = 'Images/availableSquare.png';

    // Wait for background/other images to load before drawing to canvas
    background.onload = function()
    {
      // draw background
      ctx.drawImage(background,0,0, width, height);

      // draw checker pieces and assign images to checkerPieceArray objects.
      
      var pieceNumber = 0;
      // used to track the images as they are assigned to their respective checkerPieceArray objects.

      var loopCount = 0;
      var placementCount = 0;
      var everyOther;

      for(var j = 0; j < height; j += (height/8)){

        // used to track which rows to draw the chips on.
        loopCount++;
         // probably not a necessary variable

        for(var i = 0; i < width; i += (width/8)){
          
          placementCount++;
          // used to skip spots on the board that shouldn't have a chip placed

          // FOR BLACK CHIPS
          if(loopCount <= 3)
          {
            if(loopCount == 1 || loopCount == 3)
            {
              if(placementCount == 1 || placementCount == 3 || placementCount == 5|| placementCount == 7) // draw chips in correct places for row 1 & 3
              {
                // draw checker piece to screen
                ctx.drawImage(blackChips, i, j, (width/8), (height/8));

                // image coordinates for each checker piece
                checkerPieceArray[pieceNumber].setX(i);
                checkerPieceArray[pieceNumber].setY(j);

                // board location coordinates for each checker piece
                checkerPieceArray[pieceNumber].setBoardX(returnBoardX(i));
                checkerPieceArray[pieceNumber].setBoardY(returnBoardY(j));
                
                // add one to pieceNumber to help keep track of which location/images are being assigned to checkerPieceArray[].
                pieceNumber++;
              }
            }
            else // loopCount == 2
            {
              if(placementCount == 2 || placementCount == 4 || placementCount == 6 || placementCount == 8) // draw chips in correct places for row 2
              {
                // draw checker piece to screen
                ctx.drawImage(blackChips, i, j, (width/8), (height/8));

                // image coordinates for each checker piece
                checkerPieceArray[pieceNumber].setX(i);
                checkerPieceArray[pieceNumber].setY(j);

                // board location coordinates for each checker piece
                checkerPieceArray[pieceNumber].setBoardX(returnBoardX(i));
                checkerPieceArray[pieceNumber].setBoardY(returnBoardY(j));

                // add one to pieceNumber to help keep track of which location/images are being assigned to checkerPieceArray.
                pieceNumber++;
              }
            }
          }
          else // FOR RED CHIPS
          {
            if(loopCount == 6 || loopCount == 8)
            {
              if(placementCount == 2 || placementCount == 4 || placementCount == 6 || placementCount == 8)// draw chips in correct places for row 6 & 8
              {
                // draw checker piece to screen
                ctx.drawImage(redChips, i, j, (width/8), (height/8));

                // image coordinates for each checker piece
                checkerPieceArray[pieceNumber].setX(i);
                checkerPieceArray[pieceNumber].setY(j);

                // board location coordinates for each checker piece
                checkerPieceArray[pieceNumber].setBoardX(returnBoardX(i));
                checkerPieceArray[pieceNumber].setBoardY(returnBoardY(j));

                // add one to pieceNumber to help keep track of which location/images are being assigned to checkerPieceArray.
                pieceNumber++;
              }
            }
            else // loopCount == 7
            {
              if(placementCount == 1 || placementCount == 3 || placementCount == 5 || placementCount == 7)// draw chips in correct places for row 7
              {
                // draw checker piece to screen
                ctx.drawImage(redChips, i, j, (width/8), (height/8));

                // image coordinates for each checker piece
                checkerPieceArray[pieceNumber].setX(i);
                checkerPieceArray[pieceNumber].setY(j);

                // board location coordinates for each checker piece
                checkerPieceArray[pieceNumber].setBoardX(returnBoardX(i));
                checkerPieceArray[pieceNumber].setBoardY(returnBoardY(j));

                // add one to pieceNumber to help keep track of which location/images are being assigned to checkerPieceArray.
                pieceNumber++;
              }
            }
          }
        }

        if(loopCount == 3) // skip middle two rows
        {
          j += 2*(height/8);
          loopCount++; // skipped two loopCounts so they need to be added here.
          loopCount++;
        }
        placementCount = 0;
      }
      // after background .onload has run, change readyState and reiterate through main() so that game can progress with all data loaded.
      readyState = true;
      main();
    };

    // not necessary for functionality
    // initBoardArray();
     }


      // INITCHECKERPIECEARRAY FUNCTION
     function initCheckerPieceArray(){
      checkerPieceArray = [];
      var nameString;

      for(a = 0; a < 24; a++)
      {

        if(a < 12)
        {
          nameString = 'black' + a;
          checkerPieceArray.push(new checkerPiece(nameString, 'black', 'Images/BlackChecker.png'));
          checkerPieceArray[a].createImage();
        }
        else
        {
          nameString = 'red' + a;
          checkerPieceArray.push(new checkerPiece(nameString, 'red', 'Images/RedChecker.png'));
          checkerPieceArray[a].createImage();
        }
      } 
     }


     // returns board X location based on image X coordinates
     function returnBoardX(pxX){
      if(pxX < (width/8)){
        return 0; 
      }
      else if(pxX < ((width/8)*2)){
        return 1;
      }
      else if(pxX < ((width/8)*3)){
        return 2;
      }
      else if(pxX < ((width/8)*4)){
        return 3;
      }
      else if(pxX < ((width/8)*5)){
        return 4;
      }
      else if(pxX < ((width/8)*6)){
        return 5;
      }
      else if(pxX < ((width/8)*7)){
        return 6;
      }
      else if(pxX < width){
        return 7;
      }
      else{
        window.alert("Something went wrong with returnBoardX");
      }
      return null;
     }

     // returns board Y location based on image Y coordinates
     function returnBoardY(pxY){
      if(pxY < (height/8)){
        return 0;
      }
      else if(pxY < ((height/8)*2)){
        return 1;
      }
      else if(pxY < ((height/8)*3)){
        return 2;
      }
      else if(pxY < ((height/8)*4)){
        return 3;
      }
      else if(pxY < ((height/8)*5)){
        return 4;
      }
      else if(pxY < ((height/8)*6)){
        return 5;
      }
      else if(pxY < ((height/8)*7)){
        return 6;
      }
      else if(pxY < height){
        return 7;
      }
      else{
        window.alert("Something went wrong with returnBoardX");
      }
      return null;
     }

    // EVENT CONTROLLERS

     function touchDown(){
      event.preventDefault();
      canvas_x = event.targetTouches[0].pageX;
      canvas_y = event.targetTouches[0].pageY;

      // necessary for tablets

      canvas_x -= canvas.offsetLeft;
      canvas_y -= canvas.offsetTop;

      //make sure no other pieces are already selected
      if(pieceSelected[0] == false){
        //detect if click landed on a checker piece
        if(checkerPieceSelected(canvas_x, canvas_y) == true){
          //pieceSelected[0] = true;
          redraw();
          drawAvailableMoves(pieceSelected[1]);

        }
      }
      // checker piece has already been selected
      else if(pieceSelected[0] == true)
      {

        //will run through the checkerPieceSelected function and not allow any other checker pieces to be clicked while the current chip is still selected.
        if(checkerPieceSelected(canvas_x,canvas_y) == true){
          redraw();
          // deselect current chip if clicked again
        }
        else
        {
          movePiece(canvas_x, canvas_y, pieceSelected[1]);
          // move current chip to available position clicked on
        }
      }
      checkForKings();
     }

     function mouseDown(){
      canvas_x = event.x;
      canvas_y = event.y;

      canvas_x -= canvas.offsetLeft;
      canvas_y -= canvas.offsetTop;

      //make sure no other pieces are already selected
      if(pieceSelected[0] == false){
        //detect if click landed on a checker piece
        if(checkerPieceSelected(canvas_x, canvas_y) == true){
          //pieceSelected[0] = true;
          redraw();
          drawAvailableMoves(pieceSelected[1]);
        }
      }
      // checker piece has already been selected
      else if(pieceSelected[0] == true)
      {
        //will run through the checkerPieceSelected function and not allow any other checker pieces to be clicked while the current chip is still selected.

        if(checkerPieceSelected(canvas_x,canvas_y) == true){
          // deselect current chip if clicked again
          redraw();
        }
        else
        {
          movePiece(canvas_x, canvas_y, pieceSelected[1]);
          // move current chip to available position clicked on
        }
      }
      checkForKings();
     }


     // game mechanic functions

     function checkerPieceSelected(x, y){
      // represents an individual box area on the board
      var box;
      // load box[] with coordinates that belong to each checker piece
      if(redTurn == true){
        for(i = 0; i < checkerPieceArray.length; i++){
          if(checkerPieceArray[i].team == 'red'){
            var x1, x2, y1, y2;
            x1 = checkerPieceArray[i].x;
            x2 = x1 + (width/8);
            y1 = checkerPieceArray[i].y;
            y2 = y1 + (height/8);
            box = [x1, x2, y1, y2];
            // check if click was within the box area around checker piece
            if(x >= box[0] && x <= box[1]){
              if(y >= box[2] && y <= box[3]){
                // if checker piece is already selected, deselect it
                if(pieceSelected[1] == i){
                  unselectedImage(i);
                  pieceSelected[1] = null;
                  pieceSelected[0] = false;
                }
                else // if checker piece has not been selected yet, select it
                {
                  //update image source of chip clicked on with "selected" image of itself
                  if(pieceSelected[1] == null){
                    selectedImage(i);
                    pieceSelected[1] = i;
                    pieceSelected[0] = true;
                  }else{
                    // a piece is selected and the user just clicked on a different piece.
                    // this stops the game from calling redraw(); when not deselecting his own piece.


                    //later this will include actions to be taken when moving to an available space.
                    return false;
                  }
                }
                return true;
              }
            }
          }
        }
      }
      else // redTurn == false
      {
        for(i = 0; i < checkerPieceArray.length; i++){
          if(checkerPieceArray[i].team == 'black'){
            var x1, x2, y1, y2;
            x1 = checkerPieceArray[i].x;
            x2 = x1 + (width/8);
            y1 = checkerPieceArray[i].y;
            y2 = y1 + (height/8);
            box = [x1, x2, y1, y2];
            // check if click was within the box area around checker piece
            if(x >= box[0] && x <= box[1]){
              if(y >= box[2] && y <= box[3]){
                // if checker piece is already selected, deselect it
                              // if checker piece is already selected, deselect it
                  if(pieceSelected[1] == i){
                    unselectedImage(i);
                    pieceSelected[1] = null;
                    pieceSelected[0] = false;
                  }
                  else // if checker piece has not been selected yet, select it
                  {
                    //update image source of chip clicked on with "selected" image of itself
                    if(pieceSelected[1] == null){
                      selectedImage(i);
                      pieceSelected[1] = i;
                      pieceSelected[0] = true;
                    }else{
                      // a piece is selected and the user just clicked on a different piece.
                      // this stops the game from calling redraw(); when not deselecting his own piece.


                      //later this will include actions to be taken when moving to an available space.
                      return false;
                    }
                  }
                return true;
              }
            }
          }
        }
      }
      
      return false;
     }

     function movePiece(x, y, n){

      var moves = checkerPieceArray[n].availableMoves(n);
      var aMoves = moves[0];
      var pMoves = moves[1];
      var intX = returnBoardX(x);
      var intY = returnBoardY(y);
      var pieceToKill = [false, null];


      // run through available moves
      for(i = 0; i < aMoves.length; i++){
        // if move is available and click coordinates are within board coords..
        if(aMoves[i] == true && intX == pMoves[i][0] && intY == pMoves[i][1]){
          // then, update the selected checker piece's coords to the new coords
          checkerPieceArray[n].setBoardX(intX);
          checkerPieceArray[n].setBoardY(intY);
          checkerPieceArray[n].setX(intX * (width/8));
          checkerPieceArray[n].setY(intY * (height/8));
          //window.alert('in movepiece');

          // run through stored available jump moves if there are any
          if(aJumpMoves[0][0] != undefined || aJumpMoves[1][0] != undefined || aJumpMoves[2][0] != undefined || aJumpMoves[3][0] != undefined){
           // window.alert();
            for(j = 0; j < aJumpMoves.length; j++){
              //window.alert("running through available jump moves");
              // if move made by player is one of the jump moves, kill the piece that was jumped over
              if(intX == aJumpMoves[j][0] && intY == aJumpMoves[j][1]){
                pieceToKill = [true, aJumpMoves[j][2]];
              }
            }
            aJumpMoves = [[],[],[],[]];
          }

          // change image of chip back to its unselected image
          unselectedImage(n);

          // Make sure there is a piece to be killed, then kill it
          if(pieceToKill[0] == true){
            kill(pieceToKill[1]);
            pieceToKill = [false, null];
            aJumpMoves = [[],[],[],[]];

            // check to see if another jump is available
            if(redTurn == true){
              // since a red is killing a black it will decrease the array by one piece NEXT turn so when you run available moves next turn you need to run it for the position that this red checker piece will be in in the array
              moves = checkerPieceArray[n-1].availableMoves(n-1);
              // reloads aJumpMoves if there are any available
            }
            else// black turn
            {
              moves = checkerPieceArray[n].availableMoves(n);
              // reloads aJumpMoves if there are any available
            }
          }

          // reset pieceSelected for next turn
          pieceSelected[0] = false;
          pieceSelected[1] = null;

          // toggle turn switching
          toggleTurn();
          aJumpMoves = [[],[],[],[]];
          
          // update board to reflect changes
          redraw();
        }
      }
      // check to see if any checker pieces have become kings
      
     }

     function toggleTurn(){
      if(aJumpMoves[0][0] != undefined || aJumpMoves[1][0] != undefined || aJumpMoves[2][0] != undefined || aJumpMoves[3][0] != undefined){
        if(redTurn == true){
          //let red go again, there is another jump move available
        }else if(redTurn == false){
          //let black go again, there is another jump move available
        }
      }
      else if(redTurn == true){
        redTurn = false;
      }else if(redTurn == false){
        redTurn = true;
      }
      checkForWin();
     }

     // test for win/lose conditions
     function checkForWin(){
      var blackAlive = false;
      var redAlive = false;
      for(i = 0; i < checkerPieceArray.length; i++){
        if(checkerPieceArray[i].team == 'black'){
          blackAlive = true;
        }
        if(checkerPieceArray[i].team == 'red'){
          redAlive = true;
        }
      }
      if(redAlive == true && blackAlive == true){

      }else{
        if(redAlive == true && blackAlive == false){
          window.alert("Red Wins!!!\n Close this dialog to restart the game.");
          readyState = false;
          main();
        }
        if(redAlive == false && blackAlive == true){
          window.alert("Black Wins!!!\n Close this dialog to restart the game,");
          readyState = false;
          main();
        }
      }
     }

     // check if any pieces have become king pieces and update them accordingly
     function checkForKings(){
      for(i = 0; i < checkerPieceArray.length; i++){
        var temp = checkerPieceArray[i];
        if(temp.team == 'black' && temp.boardY == 7){
          temp.isKing = true;
          temp.imageSource = 'Images/BlackCheckerKing.png';
          temp.createImage();
        }
        if(temp.team == 'red' && temp.boardY == 0){
          temp.isKing = true;
          temp.imageSource = 'Images/RedCheckerKing.png';
          temp.createImage();
        }
      }
     }

     // removes checker piece n
     function kill(n){
      checkerPieceArray.splice(n,1);
     }

     function redraw(){
      // draw background over old board
      ctx.drawImage(background, 0, 0, width, height);
      // redraw all checker pieces
      for(i = 0; i < checkerPieceArray.length; i++){
        ctx.drawImage(checkerPieceArray[i].image, checkerPieceArray[i].x, checkerPieceArray[i].y, (width/8),(height/8));
      }
     }

     function drawAvailableMoves(i){
      // draw availableSquare.png around selected checker piece
      var moves = checkerPieceArray[i].availableMoves(i);
      var aMoves = moves[0];
      var pMoves = moves[1];
      for(i = 0; i < aMoves.length; i++){
        // if move is available then draw aSquare to that location on the canvas
        if(aMoves[i] == true){
          ctx.drawImage(aSquare, pMoves[i][0] * (width/8), pMoves[i][1] * (height/8), (width/8), (height/8));
        }
      }
     }

     // simply used to change image source of a checkerpiece to its selected couterpart and then refresh that checker piece's image object
     function selectedImage(i){
      var temp = checkerPieceArray[i];

      // BlackCheckerKingSelected
      if(temp.team == 'black' && temp.isKing == true){
        temp.imageSource = 'Images/BlackCheckerKingSelected.png';
        temp.createImage();
      }
      // BlackCheckerSelected
      if(temp.team == 'black' && temp.isKing == false){
        temp.imageSource = "Images/BlackCheckerSelected.png";
        temp.createImage();
      }

      // RedCheckerKingSelected
      if(temp.team == 'red' && temp.isKing == true){
        temp.imageSource = 'Images/RedCheckerKingSelected.png';
        temp.createImage();
      }
      // RedCheckerSelected
      if(temp.team == 'red' && temp.isKing == false)
      {
        temp.imageSource = "Images/RedCheckerSelected.png";
        temp.createImage();
      }
     }

     // simply used to change image source of a checkerpiece back to its unselected image source.
     function unselectedImage(i){
      var temp = checkerPieceArray[i];

      // BlackCheckerKing
      if(temp.team == 'black' && temp.isKing == true){
        temp.imageSource = 'Images/BlackCheckerKing.png';
        temp.createImage();
      }
      // BlackChecker
      if(temp.team == 'black' && temp.isKing == false){
        temp.imageSource = "Images/BlackChecker.png";
        temp.createImage();
      }

      // RedCheckerKing
      if(temp.team == 'red' && temp.isKing == true){
        temp.imageSource = 'Images/RedCheckerKing.png';
        temp.createImage();
      }
      // RedChecker
      if(temp.team == 'red' && temp.isKing == false)
      {
        temp.imageSource = "Images/RedChecker.png";
        temp.createImage();
      }
     }

     // called after first intialization of canvas to refresh it a few times in case background.jpg loaded before the other images that require loading as well
     function refreshRedraw(n){
      for(i = 0; i < n; i++){
        redraw();
      }
     }


    </script>
  </body>
</html>
